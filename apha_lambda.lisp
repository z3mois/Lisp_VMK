(defun ErrSl (L)
    (cond ((null L) (print "Ошибка: нет параметров после /") Nil)
          ((symbolp (car L)) 
                (cond ((null (cdr L)) (print "Ошибка: нет >") Nil)
                      ((equal '> (cadr L)) T)
                      (T (print "Ошибка: неправильно указано /_> в абстракции") Nil)
                )
          )
          (T (print "Ошибка: неправильно указан параметр абстракции") Nil)
    )
)

(defun TakeParam (L N)
    (cond ((= N 0) Nil)
          (T (cons (car L) (TakeParam (cdr L) (- N 1))))
    )
)

(defun processing (Oldl)
    (cond ((null Oldl) nil)
          ((atom Oldl) Oldl)
          ((atom (car Oldl))
                (cond (( and (equal '/ (car Oldl)) (ErrSl (cdr Oldl)))
                      (cond ((equal '/ (cadddr Oldl)) (append (TakeParam Oldl 3) (list (processing (cdddr Oldl)))))
                            (T (append (TakeParam Oldl 3) (analysis (cdddr Oldl))))
                      ))
                )
          )
          (T (cons (processing (car Oldl)) (processing (cdr Oldl))))
    )
)

(defun syntax (L)
    (cond ((null L) nil)
          ((null (cdr L)) (processing (car L)))
          (T (cons (syntax (cdr L)) (list (processing (car L) ))))
    )
)

(defun analysis (L)
    (cond ((null L) nil)
          ((null (cdr L)) L)
          ((equal '/ (car L)) (processing L))
          (T (syntax (reverse L)))
    )
)

(defun closed_list (L p_list inner_list)
    (cond ((null L) p_list)
          ((atom L) (cond ((symbolp L) (cond ( (and (not (member L inner_list)) (not (member L p_list))) ( closed_list Nil (cons L p_list) inner_list))
                                                                    (T (closed_list Nil p_list inner_list))
                                                              )
                                           )       
                                           (T (closed_list Nil p_list inner_list))
                                     ) 
          )
          ((equal (car L) '/) (close_l L p_list inner_list))
;          ( (not (listp (cadr L)))  (cond ( (and ( not (member (cadr L) p_list)) (symbolp (cadr L))) ( closed_list (car L) (cons (cadr L) p_list) inner_list))
;                                (T (closed_list (car L) p_list inner_list))
;                           )
;          )
          ;cadr
          (T (result (append (close_l (cdr L) p_list inner_list) (closed_list (car L) p_list inner_list))))
    )
)

(defun close_l (L p lambda_p)
;lambda_p - список переменных в лямбда-абстракции
    (cond ((null L) nil)
          ((equal '/ (car L)) (close_l (cdddr L)  p (sym_swap (cadr L) lambda_p)))
          ((listp (car L)) (append (close_l (car L) p lambda_p) (close_l (cdr L) p lambda_p)))
          (T (closed_list L p lambda_p))
    )
)

(defun not_sign (sym)
    (cond ((member sym '(+ - / * < > =)) Nil) 
          ((quote sym))
    )
)

(defun sym_swap (sym lambda_p)
    (cons sym lambda_p)
)

(defun result (L)
   (cond ((null L) Nil)
         ((member (car L) (cdr L)) (result (cdr L)))
         (T (cons (car L) (result (cdr L))))
   )
)

(defun unnamed (free_l L new_l names_for_change)
    ;free_l - список свободных переменных, new_l - список переименованных переменных
    (cond ((null L) nil)
          ((and (member (car L) free_l) (in_l (car L) new_l)) (cons (change_n (car L) new_l) (unnamed free_l (cdr L) new_l names_for_change)))
          ((member (car L) free_l) (cons (car names_for_change) (unnamed free_l (cdr L) (cons (cons (car L) (car names_for_change)) new_l) (cdr names_for_change))))
          (T (cons (car L) (unnamed free_l (cdr L) new_l names_for_change)))
    )
)

(defun all_names (L)
    (cond ((null L) nil)
          ((listp (car L)) (cons (all_names (car L)) (all_names (cdr L))))
          (T (cond ((member (car L) '(+ - / * < > =)) (all_names (cdr L))) 
                   (T (cons (car L) (all_names (cdr L))))
             )
          )
    )
)

(defun in_l (sym l)
    (cond ((null l) nil)
          ((equal (caar l) sym) T)
          (T (in_l sym (cdr l)))
    )
)

(defun change_n (sym l)
    (cond ((null l) nil)
          ((equal (caar l) sym) (cadar l))
          (T (change_n sym (cdr l)))
    )
)

(defun work_function (L)
    (print (analysis L) )
    (cond ((null (closed_list (analysis L) () () )) (print "Замкнута") L)
          (T (print (closed_list (analysis L) () () )) (f1  L () names_for_change ()))
    )
    ;(unnamed (closed_list (analysis L) () () ) L () names_for_change )
    ;(f1  L () names_for_change ())
)

(defun f1 (L lam_l names_for_change new_l)
    (cond ((null L) nil)
          ((equal '/ (car L)) (cons (car L) (cons (car names_for_change) (f1 (cddr L) (cons (cadr L) lam_l) (cdr names_for_change) (cons (cons (cadr L) (list (car names_for_change))) new_l)))))
          ((member (car L) lam_l) (cons (change_n (car L) new_l) (f1 (cdr L) lam_l names_for_change new_l)))
          ((listp (car L)) (append (list (f1 (car L) lam_l names_for_change new_l)) (f1 (cdr L) lam_l names_for_change new_l)))
          (T (cons (car L) (f1 (cdr L) lam_l names_for_change new_l)))
    )
)

(defun flatten (l)
    (apply 'append (mapcar (lambda (x) (if (atom x) (list x) (flatten x))) l)))

(defvar names_for_change '(x1 x2 x3 x4 x5 x6 x7 x8 x9 x10))

(print (work_function '((/ x > / y > x (/ z > y z w)) (((/ w > / y > y) 8) (/ x > (/ y > y) x)) )))
(print (work_function '((/ x > / y > x y ( / x > / y > y z)) (/ x > / y > x) (/ x > / y > y))))